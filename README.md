# GenDB

[![Actions Status](https://github.com/probcomp/hierarchical-irm/workflows/Python%20package/badge.svg)](https://github.com/probcomp/hierarchical-irm/actions)
[![pypi](https://img.shields.io/pypi/v/hirm.svg)](https://pypi.org/project/hirm/)

This repository contains an implementation of GenDB, a Bayesian method for
automatic structure discovery in tabular and relational data.

A paper describing this method is in preparation.  Briefly, this codebase
builds on the [Hierarchical Infinite Relations
Model](https://proceedings.mlr.press/v161/saad21a.html) implemented
in <https://github.com/probsys/hierarchical-irm> and
adds:

1. Many more distribution types, including a normal distribution for floating
point data, categorical and Skellam distributions for integer data, and a
bigram distribution for string data.

2. Hyperparameter inference.

3. Support for distributions like Skellam without conjugate priors.

4. Support for "noisy relations", which add noise to the output of another
relation.

5. A library of emission classes for noisy relations, including a gaussian
emission for adding gaussian noise to real data, a bitflip emission for
adding noise to boolean data, and a bigram emission for adding insertions,
substitutions and deletions to string data.

In addition, we use these capabilities to build an entirely new interface
to the HIRM model:  the pclean binary (named after the
[PClean paper](https://proceedings.mlr.press/v130/lew21a/lew21a.pdf) on which
it is heavily based) reads in tabular data and a schema describing the entities
that generated it, and converts the data and schema into their HIRM equivalents.


## Installation (C++)

First obtain a GNU C++ compiler, version 7.5.0 or higher.
The underlying code can be built and installed via bazel. To install bazel:

    $ sudo apt-get install bazel

If bazel is not available, first add the Bazel distribution URI as discussed
on this [page](https://bazel.build/install/ubuntu).

The binaries can be generated by first cloning this repository and then writing

    $ cd cxx
    $ bazel build -c opt ...

The unit tests can be invoked via

    $ bazel test ...

And the integrate tests with

    $ ./integration_tests.sh

## Usage: HIRM

Here is an example usage of the HIRM binary:

    $ cd cxx
    $ bazel build -c opt :hirm
    $ ./bazel-bin/hirm assets/animals.unary
    setting seed to 10
    loading schema from assets/animals.unary.schema
    loading observations from assets/animals.unary.obs
    selected model is HIRM
    incorporating observations
    inferring 10 iters; timeout 0
    saving to assets/animals.unary.10.hirm

Let's take a look at the two input files.

The first, which must have the name <path>.schema, looks like this:

```
$ head assets/animals.unary.schema
black ~ bernoulli(animal)
white ~ bernoulli(animal)
blue ~ bernoulli(animal)
brown ~ bernoulli(animal)
gray ~ bernoulli(animal)
orange ~ bernoulli(animal)
red ~ bernoulli(animal)
yellow ~ bernoulli(animal)
patches ~ bernoulli(animal)
spots ~ bernoulli(animal)
```

Each line specifies the signature of a relation in the system:

- The first token is the name of the relation; all the relation names must be
  unique.
- The second token is the `~` character.
- The third token is the observation type.  See the `DistributionSpec`
  definition for supported values for clean relations and the `EmissionSpec`
  definition for supported values for noisy relations.
- Inside the parenthesis is the list of domains of the relation.  In this
  example, the only domain is `animal`.

Thus, for this schema, we have a list of unary relations that each specify
whether an `animal` has a given attribute.

Note that, in general a given relational system can be encoded in multiple
ways. See `assets/animals.binary.schema` for an encoding of this system using
a single higher-order relation with signature:
`has ~ bernoulli(feature, animal)`.

The second input, which must be at <path>.obs, contains the observations
of the relations.  Observation files are comma separated values (CSV) and
look like

```
$ head assets/animals.unary.obs
0,black,antelope
1,black,grizzlybear
1,black,killerwhale
0,black,beaver
1,black,dalmatian
0,black,persiancat
1,black,horse
1,black,germanshepherd
0,black,bluewhale
1,black,siamesecat
```

Each line specifies a single observation:

- The first entry is 0 or 1.  This is because all of the relations in this
  example are bernoulli, which is boolean valued.  If we had used a ``normal``
  distribution instead, the first entry would be real valued.  If we had
  used a ``bigram`` distribution, the first entry would be string valued.
- The second entry is the relation name.  There must be a corresponding
  relation with the same name in the schema file.
- The third and subsequent entries are the names of domain entities; e.g,
  `antelope`, `grizzlybear`, etc., are entities in the `animals` domain.
  The number of domain entities on a line must correspond to the arity of the
  corresponding relation in the schema file. Since all the relations in this
  example are unary, there is only one entity after each relation name.

Thus, for this observation file, we have observations `black(antelope) = 0`,
`black(grizzlybear) = 1`, and so on.

Finally, let's take a look at the output file, `assets/animals.unary.10.hirm`.
It contains the clusterings of the relations and domain entities that the
system learned during inference.  The output is comprised of multiple sections,
each delimited by a single blank line.

```
$ cat assets/animals.unary.10.hirm
0 oldworld black insects skimmer chewteeth agility bulbous fast lean orange inactive slow stripes tail red active
1 quadrapedal paws strainteeth pads meatteeth hooves longneck ocean coastal hunter hairless smart group nocturnal meat buckteeth plankton plains timid horns hibernate forager ground grazer furry fields brown solitary stalker toughskin water arctic blue smelly claws swims vegetation fish flippers walks
5 mountains jungle forest bipedal cave desert fierce nestspot tree tusks yellow hands scavenger flys
6 muscle longleg domestic tunnels newworld bush big gray spots strong weak patches white hops small

irm=0
animal 0 giraffe seal horse bat rabbit chimpanzee killerwhale dalmatian mole chihuahua zebra deer lion mouse raccoon dolphin collie bobcat tiger siamesecat germanshepherd otter weasel spidermonkey beaver leopard antelope gorilla fox hamster squirrel wolf rat
animal 1 skunk persiancat giantpanda polarbear moose pig buffalo elephant cow sheep grizzlybear ox humpbackwhale walrus rhinoceros bluewhale hippopotamus

irm=1
animal 0 mouse rabbit zebra moose antelope horse buffalo deer ox cow gorilla pig rhinoceros chimpanzee giraffe sheep spidermonkey elephant
animal 1 collie germanshepherd siamesecat giantpanda chihuahua lion raccoon squirrel grizzlybear dalmatian rat persiancat weasel leopard skunk bobcat mole tiger hamster fox wolf
animal 3 otter walrus humpbackwhale killerwhale bluewhale dolphin seal
animal 4 polarbear bat
animal 5 hippopotamus beaver

irm=5
animal 0 antelope germanshepherd elephant hippopotamus tiger rhinoceros zebra giraffe killerwhale sheep humpbackwhale mole hamster persiancat horse siamesecat chihuahua cow dolphin walrus collie polarbear mouse pig deer moose skunk bluewhale buffalo dalmatian rat beaver ox fox seal rabbit wolf weasel otter
animal 1 squirrel raccoon giantpanda gorilla lion bat spidermonkey chimpanzee grizzlybear bobcat leopard

irm=6
animal 0 horse killerwhale spidermonkey deer giraffe germanshepherd rhinoceros leopard moose fox wolf buffalo dolphin bluewhale grizzlybear chimpanzee walrus lion bobcat zebra beaver elephant ox antelope gorilla hippopotamus humpbackwhale polarbear tiger
animal 1 collie squirrel raccoon chihuahua sheep hamster rabbit rat mouse skunk persiancat weasel mole bat otter siamesecat
animal 2 dalmatian giantpanda cow pig
animal 3 seal
```

The first section of the file shows how the relations were clustered.  In
this example, the system found four clusters and gave them the labels 0, 1,
5 and 6.  The subsequent sections show the sub-clustering of entities within
a given relation cluster.  For example, the `irm=6` section shows the clustering
within the `6` relation cluster and the line

```
animal 2 dalmatian giantpanda cow pig
```

says that those four animals get clustered together within that relation
cluster.  This example only has one domain (animal), but if there were
multiple domains, their entities would get assigned to clusters and be
listed in this section as well.

Please see the file `cxx/integration_tests.sh` for more examples of using
the hirm binary, and run `./bazel-bin/hirm --help` for more information
about its options.

## Usage: PClean

Here is an example usage of the pclean binary:

    $ cd cxx
    $ bazel build -c opt pclean:pclean
    $ ./bazel-bin/pclean/pclean --schema=assets/flights.schema --obs=assets/flights_dirty.10.csv --iters=5


## License

Copyright (c) 2024

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
